本章的内容主要总结自以下文章：

## 将复杂的业务写成两条sql还是写成一条比较好？

## 长sql的效率高还是多个短sql的效率高？

## 数据库三范式？
[什么是数据库三大范式，它们是做什么的？](https://www.zhihu.com/question/273637851/answer/1101209646)

[MySQL数据库三范式](https://zhuanlan.zhihu.com/p/72197799)

[alibabacloud——Three paradigms of database design](https://topic.alibabacloud.com/a/three-paradigms-of-database-design_8_8_30019153.html)

第一范式：保证**每个字段**都是不可分割的，符合原子性。

是否遵守第一范式应该取决于具体的场景，例如有些系统可能需要访问省份或者地级市这些信息，那么“地址”字段=“浙江省杭州市xxxx”，可以拆分为“省份”=“浙江”，“市”=“杭州”，“地址”=“xxxx	”

第二范式：基于第一范式，保证**每个数据表**只有一个主键，其它字段**完全依赖**于主键。也就是说一张表只描述一件事。如果要描述两件事，就用三张表表示（两张数据表和一张关系表）。

例如订单表中有订单 id，那么其余属性必须只与订单 id 有关。商品名称这种字段是不能在内的。

因为订单表和商品表应该是两件不同的事情。

第三范式：基于第二范式，保证数据表中的字段只能**直接依赖**于主键，不能**间接依赖**，这是为了消除**传递依赖**。数据表中不应该出现与主键有传递依赖的字段，例如学生表却有一个“所修学分”的字段。虽然这样方便做查询，但是学分不应该和学生绑定。


第二范式是为了保证数据表中的字段是与主键相关的，可以通过主键找到这些字段。

第三范式是为了消除传递依赖，一张数据表中不要存放间接依赖的字段。

## 讲讲数据库的分库分表
可以使用垂直切分和水平切分两种方式切分数据表。

垂直切分将数据表中的字段切开，存到不同的表中。

水平切分将不同的数据切开，存到不同的表中。

分库也是一样的思路。

垂直分库就是把不同的业务拆分到不同的数据库中。

水平分库就是部署多个一样的数据库。

## char和varchar有什么区别？
char 的长度是固定的，不足的字符用空格补全。在取值时，会取出后面的空格（[哪怕是写入时包含空格](https://www.zhihu.com/question/360072501)）。

varchar 的长度是可变的，可以存入不同长度的字符串。

<del>char 的长度计算的是字符个数，varchar 的长度计算的是字节个数。</del>（放屁）

char 的优势是性能更好，varcahr 的优势是更省空间。

## mysql有哪些连接方式？
内连接：inner join，简写为 join

左连接：左外连接，left [outer] join

右连接：右外连接，right [outer] join

全连接：full [outer] join，mysql 暂时不支持

交叉连接：cross join，返回两个表的笛卡尔乘积，即计算所有可能的组合。

## 自连接,外连接,内连接有什么区别

## 讲讲什么是事务？
事务是一系列操作的集合，这些操作要么同时成功，要么同时失败。结束事务只有两种可能，要么是提交，要么是回滚。

## 事务有哪些特性？
有四种特性，分别是：原子性、一致性、隔离性和持久性。

原子性指的是，事务是不可分割的最小单位，事务中的操作要么同时成功，要么同时失败。

一致性指的是：事务执行前后，数据库总是保持一致性。也就是说数据库中的数据满足真实的世界的约束。（数据库的一致性指的是，随着状态转移，数据库总是保持正确的状态。“正确”指的是数据满足真实世界的约束。）

隔离性指的是：事务与事务之间互不影响，保持隔离。

持久性指的是：事务一旦提交或者回滚，对数据的改变就是永久的。

## 讲讲数据库的三种读取现象？
脏读：事务可以查询到其它事务数据已经修改但还没有提交的数据。

不可重复读：在事务执行过程中，执行两次相同的查询，但是得到了不同的结果。这是因为其它事务修改或删除了这些数据。

幻读：在事务执行过程中，执行两次完全一致的查询，但是返回的结果集是不同的。这是因为其它事务在当前事务的操作范围内又新增了一些数据。（这些数据在 where 子句的范围内）

## 讲讲四种隔离级别？
读未提交：事务可以读到其他事务已修改但还未提交的数据，这是最低的级别。可以发生脏读、不可重复读和幻读三种现象。

读已提交：事务只能读到其它事务已提交的数据，这样就无法发生脏读现象了，不过其它两种还是可以发生。

可重复读：在事务执行过程中，执行两次相同的查询，保证查询的结果是一致的。不过在 InnoDB 存储引擎中，这个隔离级别还可以解决幻读现象。**不过也不能完全解决**。详见下一条。

串行化：与可重复读类似，它指的是执行两次完全一致的查询，保证返回的结果集是相同的。因此解决了幻读现象。

*一致性读取——快照*

读已提交和可重复读使用了一种一致性非锁定读取的机制，它保证了事务在检索数据的时候，获取的是某个时间点的快照。

两种隔离级别的具体实现方式有点不同。

读已提交在每次查询时获得一份快照，然后立即释放。

可重复读保证在整个事务期间内，获取的都是同一份快照。在事务结束后才会释放这份快照。

*幻读*

还可以补充一点，在使用 InnoDB 存储引擎时，可重复读和串行化都可以解决幻读现象。

可重复读有点复杂。

在快照读的时候，也就是普通的查询语句，不加 for share 或者 for update，它利用快照的机制防止了幻读现象。

在锁定读的时候，也就是加了 for share 或者 for update，它利用临键锁锁定了一个范围，这样也解决了幻读现象。

至于串行化这个隔离级别，它本身就将 select 转换成 select for share。这样就自动获取了临键锁。

临键锁只会作用在上面说的这两种隔离级别上。出自 [This level is like REPEATABLE READ](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html) 。

## InnoDB存储引擎的可重复读是否一定能解决幻读现象？
[MySQL可重复读级别不是也支持间隙锁吗，为什么还是无法解决当前读下的幻读？](https://www.zhihu.com/question/455807256/answer/1848462055)

其实可重复读也不能完全解决幻读现象。

第一种情况：

如果第一次查询时快照读，第二次是锁定读（当前读）。这样还是会发生幻读。

因为锁定读直接读取真实的数据，而不是快照。在做第一次查询后，其它事务有可能改变了真实的数据。

不过，官方认为这种不算是幻读现象。

第二种情况：

如果当前事务先做了一次快照读，然后有一个事务新插入了一条数据，最后当前事务对这条新插入的数据进行了修改。那么当前事务的第二次快照读是可以读取到这条由其它事务插入的数据的。

```sql
# 当前事务
begin;
select * from tb_lock where id =102 # 1，没有返回结果集

update tb_lock set age = 30 where id = 102 # 3，更新其它事务插入的数据

select * from tb_lock where id =102 # 4，返回了这条结果集

# 其它事务
begin;
insert into tb_lock (id, age) VALUES(102, 33); # 2，插入一条数据
COMMIT;
```

## 谈谈对MVCC的理解
[MySQL中MVCC的正确打开方式（源码佐证）](https://blog.csdn.net/Waves___/article/details/105295060#1.2%E3%80%81Read%20View%20%E7%BB%93%E6%9E%84)

[数据库基础（四）Innodb MVCC实现原理](https://zhuanlan.zhihu.com/p/52977862)

MVCC 机制是通过表的三个隐藏字段、undo log 和 read view 实现的。

三个隐藏字段分别存储的是操作数据行的事务 id，上一个版本的数据在 undo log 中的指针，还有一个隐藏 id，如果数据表没有聚集索引，那么这个隐藏 id 就被当作聚集索引。

undo log 记录了数据被修改前的版本，事务回滚的时候，可以用它还原数据。也可以用来实现 mvcc 机制。

在 InnoDB 中每个事务开启后都会创建一个 ReadView，主要保存了四个属性。分别是当前活跃并且为提交的事务 id、当前最大的事务 id + 1（下一个将被分配的事务 id）、活跃列表中最小的事务 id 以及创建这个 ReadView 的事务 id。

在查询时，如果数据的事务 id 符合 readview 中的条件，那么就将代表它对于当前事务是可见的；如果不符合就用位置指针到 undo log 中找以前的版本，同理如果数据符合条件就是可见的。

比如说，隐藏字段事务 id < 活跃事务列表中的最小值，那么数据就是可见的。因为这个数据肯定已经被提交了，并且是在当前事务之前提交的。

[ReadView 源码](https://github.com/mysql/mysql-server/blob/5.7/storage/innobase/include/read0types.h) 的末尾定义了一些变量，并解释了它们的用途。

## 在可重复读的情况下 , 一个事务用update更新了数据未提交 ,另一个事务能读到这些更新的数据吗?
不可以，可重复读已经不会发生脏读。

## 在可重复读的情况下 , 一个事务用update更新了数据已提交 ,另一个事务能读到这些更新的数据吗?
是可以的。只要更新的数据没有上锁就行，另一个事务使用锁定读可以直接读到真实的数据。

## 讲讲对乐观锁和悲观锁的理解？
乐观锁，本质上不加锁。当一个事务读取某些数据的时候，假定其它事务不会对其修改。在事务结束的时候会检查数据有没有被其它事务修改。实现的手段是为表加一个 version 的字段。每次数据被修改的时候，version 都应该 +1。

悲观锁分两种。

一种是共享锁（也叫作读锁）。当一个事务读取一些数据的时候，就为这些数据加锁，其它事务无法修改这些数据。

另一种是独占锁（也叫作写锁）。当一个事务读取一些数据的时候，其它事务进行任何操作，包括读取。

## 事务死锁
死锁是指两个或两个以上的事务，因争夺锁资源而造成的一种互相等待的现象。

死锁可能由很多原因引起，下面说一个简单的例子。

在查询某些数据时，事务 A 在索引上获得 S 锁，此时事务尚未提交。同时，事务 B 也想要获得这些数据的 S 锁。注意，S 锁并不互斥。

然后事务 A 想要更新之前查出来的数据，为此数据库自动地想要获得 X 锁（在 `UPDATE` 时，数据库会自动加 X 临键锁或者 X 记录锁）。这时，事务 A 被阻塞了。这是因为 S 锁和 X 锁冲突（不同事务之间）。同时事务 B 也想要更新这些数据，数据库也想获得 S 锁。这时，事务 B 也被阻塞了。

最终，在双方都被阻塞的情况下，发生了死锁。

## 什么时候触发表锁？
没用索引进行查询就会触发表锁。

## 什么是索引？
索引是一种 B+ 树的数据结构，在访问一些特定的数据时，它可以提高访问的速度。

索引也有缺点，数据库需要花费额外的时间和空间维护索引。例如，在增删改时需要更新索引。

索引最好建立在一些需要频繁访问并且出现在 where 子句的字段上。

## 索引失效有哪些情况？
[MySQL索引失效原理是什么？](http://www.zhihu.com/question/421944348/answer/2251613556)

[MySQL中IS NULL、IS NOT NULL、!=不能用索引？胡扯！](https://mp.weixin.qq.com/s/CEJFsDBizdl0SvugGX7UmQ)

使用 is null / is not null / <> 不一定会让索引失效

当 mysql 觉得全表扫描更快的时候，就不会用索引。

`in` 不会让索引失效，`in` 类似于执行多个 `=` 操作。

## 什么是最左匹配原则？
[最左匹配原则](https://www.cnblogs.com/lanqi/p/10282279.html)

最左匹配原则是针对联合索引的，它指的是数据库只从组合索引左边的第一个字段开始匹配，碰到范围查询就停止匹配。

(a, b, c)

where a=? and b=? 可行

where b=? and c=? 不可行

where c=? and b=? and a=? 可行

where 子句中的顺序可以是乱的，例如 `where a = 1 and b > 2 and c = 3`，可以建立组合索引 (a, c, b)。这样最左匹配原则也可以生效，会匹配到组合索引中的 b 为止。

## 你知道哪些索引？
你是说哈希索引、B+树索引这种，还是唯一索引、聚簇索引这种？

都说说。

1. 普通索引：可以为空，可以重复
2. 唯一索引：可以为空，但是不能重复
3. 主键索引：不能为空，也不能重复
4. 全文索引：只能在 char、varchar和text类型上创建
5. 组合索引：由多个列按顺序组成

## 聚簇索引
[官方文档的词汇表](https://dev.mysql.com/doc/refman/8.0/en/glossary.html)中有说明什么是聚簇索引。主键索引就是聚簇索引。

一张表只能有一个聚簇索引，指定的主键就是聚簇索引。其余索引都是次要索引（secondary index）。

## 什么是组合索引？
组合索引（composite index）是一个包括多列的索引。

数据按照组合索引中的各个字段进行排序。先按照第一个排序，如果相同，再按照第二个排序，以此类推。

## 讲讲B+树以及和B树的区别？
[What are the differences between B trees and B+ trees?](https://stackoverflow.com/questions/870218/what-are-the-differences-between-b-trees-and-b-trees)

《算法导论》（第三版）

《数据结构与算法分析——java 语言实现》（第三版）

[B+树可视化](https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html)

[MySQL的B+tree结构的叶子节点之间的指针到底是单向的还是双向的？](https://www.zhihu.com/question/409914598/answer/1364351742)

B 树是二叉查找树的推广，是一种为磁盘设计的多叉查找树，每个结点可以存放多条数据。

B+ 树是 B 树的改进，它的非叶结点不再存放数据，而是存放索引。所有的数据被存放在了叶结点上存放了，并用双向链表串联起来。

这样就比较适合做全表扫描或者范围查询。

B+ 树的非叶结点存放的不再是数据，而是索引，所以一个结点可以容纳更多的记录。

这样 B+ 树的高度就会比 B 树的高度小很多，可以减少磁盘 IO 的次数，提供访问速度。

-----

由于 B 树在每个结点都存放了数据，所以查找一些靠近根节点的数据时，速度要更快。

由于 B+ 树的非叶结点不存放数据，所以每个结点的内存可以满足更多的索引（键、地址）。这样整棵树的层数就变少了，可以使用更少的磁盘 IO 去查询数据。

B+ 树的叶结点还是以链表连接的，这个链表正好是有序的，可以用来全表扫描或者范围查询。

B 树中的数据散布在各层的所有结点上，不适合做范围查询。

这是因为 B 树想要获得范围数据，需要依靠中序遍历，而 B+ 树只需要遍历双向链表即可。

## 为什么树的高度低，磁盘IO的次数就要少？
因为B树或者B+树的每个结点都是独立存放在磁盘中的，每读一个结点都要涉及一次磁盘IO。

## B+树为什么比B树快？
上面说了。非叶结点不存放数据，所以每个结点可以存放更多的索引。这样整棵树的层数就变少了，可以使用更少的磁盘 IO 去查询数据。

## InnoDB为什么不用B树？
因为 mysql 是一个数据库，范围查询的需求很常见。B 树很难做到范围查询，需要递归遍历树，B+ 树只需要遍历双向链表就行了。

而且 B+ 树的磁盘 IO 次数更少，性能更好。

## 为什么mysql的默认索引算法不是哈希索引？
因为经常会用到范围查询，用哈希算法不太好实现。

## InnoDB的聚簇索引和非聚簇索引的B+树有没有区别？
聚簇索引和非聚簇索引的非叶结点都只存储对应的索引。*例如有两个索引 id 和 name，那么两棵 B+ 树的非叶结点分别存储的是 id 和 name。*

聚簇索引的叶结点存储的是具体的数据（不是副本），非聚簇索引的叶结点存储的是一条记录对应的主键，即聚簇索引。

## 建索引时，该选择普通索引还是唯一索引？

## 什么是回表？
非聚簇索引（也就是非主键索引、次级索引）的叶结点存储的是聚簇索引，也就是 id。

当得到 id 后，还要到聚簇索引的 B+ 树上得到数据。这被称为回表。也就是说要从两个 B+ 树中取数据。

所以如果直接按主键查数据，就不会发生回表。不用主键查就会回表。

但是也有例外。语句 `select age from xxx where age > 18` 通过非聚簇索引进行查询其本身，就不会发生回表。

因为 age 这个索引本身就在 B+ 树里。

## 索引优化？
1. 在使用组合索引的时候，要满足最左匹配原则，也就是说。。。。
2. 在使用索引的时候，要尽量避免 where 子句出现不使用索引的情况。
3. 对增删改比较频繁的字段，最好不要建立索引，因为在增删改的时候，需要修改 B+ 树的结构，这很浪费性能。
4. 尽量要避免进行回表操作，因为回表需要到两棵 B+ 树中查找数据，这是很浪费时间的。

## 如何创建索引？
普通索引：

```sql
CREATE INDEX indexName ON table_name (column_name)
```

唯一索引：

```sql
CREATE UNIQUE INDEX indexName ON table_name (column_name) 
```

## 如何修改字段？
```sql
ALTER TABLE table_name MODIFY column_name CHAR(10);
```

## 如何插入数据？
```sql
insert into table_name () values()
```

## truncate和delete有什么区别？
truncate 删除的数据是不可恢复的，delete 删除的数据可以恢复。

## delete，drop和truncate的区别？
delete：删除数据，不删除表结构，数据可恢复

truncate：删除数据，不删除表结构，数据不可恢复

drop：删除数据，删除表结构

## write skew


## ____对于几千万的大表怎么优化？
[MySQL 对于千万级的大表要怎么优化？](https://www.zhihu.com/question/19719997)

[mysql读写分离和用Redis做缓存，这两种方案有什么异同？](https://www.zhihu.com/question/31963740/answer/1905832012)

1. 可以优化一下 sql 索引，看看索引是不是正常的。
2. 还可以加缓存，不要让数据库有太大的压力，当缓存中没有数据的时候，才去数据库查。
3. 还可以读写分离，用一个主库用于写入，用多个从库用于读取。*读写分离是用来解决读性能瓶颈的。*（[大多数互联网业务都是读多写少，这时，读会首先成为数据库的瓶颈](https://www.zhihu.com/question/31963740/answer/1905832012)）
4. 最后还可以分表，垂直分表（相对容易）、水平分表（相对复杂）

[面试前必须知道的MySQL命令【explain】](https://zhuanlan.zhihu.com/p/51771446)

`explain select * from tb_lock where age > 25`，type=ALL，Extra=using where

`explain select id,age from tb_lock where age > 25`，type=range，Extra=Using where; Using index

`explain select id from tb_lock where age = 25`，type=ref，Extra=Using index

`explain select id,age from tb_lock where id = 5`，type=const，Extra=null

`explain select * from tb_lock where id = 5`，type=const，Extra=null

## 索引的扫描方式有几种

## between and 一定会走索引吗