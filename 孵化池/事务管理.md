经过查阅资料发现不同数据库管理系统对读取现象、隔离级别及其解决办法的定义具有细微差别。为此，本文仅适用于 mysql 的 InnoDB 存储引擎。由于本文的大部分内容均来自官方文档，因此可放心食用。

## 知识点
本章包括以下知识点：

1. 什么是事务？
2. 四种事务特性
3. 三种读取现象
4. 四种隔离级别
5. 什么是**一致性读取**。全称**一致性非锁定读取**，简单来说就是生成**快照**，它是实现 Read committed 和 Repeatable read 两种隔离级别的底层机制。
6. 各种锁
	1. 共享锁（share lock），亦称读锁（read lock）
	2. 独占锁（exclusive lock），亦称写锁（write lock）
	3. 概念锁：Record Lock、Gap Lock、Next-Key Lock、Insert Intention Lock、AUTO-INC Lock、Predicate Locks for Spatial Indexes
6. 更新丢失。由于 mysql 使用的是一致性读取机制。因此除了 Serializable 隔离级别，其它都会发生更新丢失。
7. Spring 的事务和锁。


## 什么是事务？
> 在一个 Java EE 的应用中，事务是一系列操作的集合，这些操作必须全部执行成功，否则每个操作的改变都要回滚。事务的末尾只有两种可能，要么是提交，要么是回滚。  
> [In a Java EE application, a transaction is a series of actions that must all complete successfully, or else all the changes in each action are backed out. Transactions end in either a commit or a rollback.](https://javaee.github.io/tutorial/transactions002.html)

## 四种事务特性
事务（Transaction）具有以下四大特性：

- 一致性（Consistency）：事务执行前后数据库状态保持一致。
- 原子性（Atomiccity）：事务是不可分割的最小操作单位，要么同时成功，要么同时失败
- 持久性（Durability）：事务一旦提交或回滚，它对数据的改变就是永久的
- 隔离性（Isolation）：并发执行事务与顺序执行事务最终获得的数据库状态是一致的（事务与事务之间互不影响，保持隔离）。*不过并不一定，可以通过设置隔离级别，略微地放宽以上限制。*

## 三种读取现象
根据 [Wikipedia](https://en.wikipedia.org/wiki/Isolation_(database_systems)) 的描述，同时参考了 [mysql 官方文档](https://dev.mysql.com/doc/refman/8.0/en/glossary.html)，共有三种读取现象（Read Phenomena）：脏读（dirty reads）、不可重复读（non-repetable reads）和幻读（phantom reads）。具体解释如下所示：（*wiki 上写的还是有点晦涩，[这里](https://stackoverflow.com/questions/11043712/what-is-the-difference-between-non-repeatable-read-and-phantom-read)有进一步的解释。*）

- 一个事务被允许读取某行中的数据，但是该数据正在被其它事务修改且尚未提交。这就发生了脏读现象。
- 在事务执行过程中，检索一行数据两次，得到了不同的结果（在检索第二次时其它事务**更新**或**删除**了该数据）。这就发生了不可重复读现象。
- 在事务执行过程中，执行两次完全一致的查询，第二次返回的行集合不同于第一次（在检索第二次时其它事务**新增**了一些数据）。这就发生了幻读现象。**注意：发生幻读现象时，新增的行一定是在 where 语句的范围内，否则不被称为幻读。**

注 1：脏读与不可重复读和幻读类似，区别在于它与读取未提交的数据有关。这种操作不符合 ACID 原则，更不安全，因为你无法预测第二个事务到底提交还是回滚。所以数据是“脏”的。脏读的对立面是一致性读取（consistent read）。

注 2：不可重复读也不符合 ACID 原则。在一个事务中，数据应该是一致，并且具有可预测和稳定的关系。

注 3：为什么要叫幻读（phantom reads）？在一个事务执行过程中，执行两次完全一致的查询却得到了不同的结果。数据表里有些行（rows）跟“鬼影 / 幻影”（phantom）一样，突然出现（insert）或消失（delete），因此被称为幻读。mysql 官方文档《[15.7.4 Phantom Rows](https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html)》有详细的解释。

## 四种隔离级别
有关事务的隔离机制，原本参考了 [Wikipedia](https://en.wikipedia.org/wiki/Isolation_(database_systems))。不过经查阅资料发现，其实 wiki 也是直接复制了 sql server 的官方文档。*并且 wiki 上写的还是有点晦涩，[这里](https://stackoverflow.com/questions/4034976/difference-between-read-commited-and-repeatable-read)有对隔离级别进一步的讨论。*由于目前还是 mysql 用的多，最终决定采用 [mysql 官方文档](https://dev.mysql.com/doc/refman/8.0/en/glossary.html)的解释。注意：原文的描述比较复杂，以下是加工后的内容，更细致的内容可以参考原文。

- Read uncommitted：（允许）读未提交。它是最低级的隔离级别，可能会发生脏读，不可重复读和幻读。
- Read committed：（只能）读已提交。在当前事务开启后，不能看见其它事务未提交的数据，但是可以看见已提交的数据。因此解决了脏读的现象。还是会发生不可重复读和幻读。
- Repeatable read：可重复读。InnoDB 的默认隔离级别。它保证正在被查询的任意行不被其它事务改变。因此解决了不可重复读的现象。
- Serializable：串行化。禁止任何其它事务插入或改变数据当事务正在读取的数据，直至当前事务结束。因此解决了幻读的现象。*相当于对表中的一个范围加锁了。*

注 0：如果还是无法理解，可以参考下一节《隔离原理》，但是在此之前应该尽量理解上述内容。

注 1：Read uncommitted 采用一种锁定策略：允许事务在通常需要等待另一个事务的情况下继续进行。虽然这能获得性能的提升，但是是以不太可靠的结果作为代价。使用这种隔离级别要非常谨慎，要注意结果可能不一致或者不可复现，这取决于其它事务同时干了什么。通常，这种级别的事务只做查询，不做插入，更新或删除操作。*因为实在太危险了。*

注 2：在 Repeatable read 隔离级别下，其它事务仍旧可以删改查这条数据。这是因为“[all consistent reads within the same transaction read the snapshot established by the first such read in that transaction.](https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html)”——在同个事务内的所有一致性读取，都会从第一次读取数据时就建立的一个快照（snapshot）中读取**。*个人测试：在该隔离级别下，一个事务访问某一行数据，另一个事务确实仍旧可以修改。*

注 3：在查阅资料时，发现网上对于四种隔离级别无法做出统一，以下是参考的各种资料：[读锁和写锁](https://stackoverflow.com/questions/7713049/read-locks-and-write-locks)、[读已提交和可重复读的区别](https://stackoverflow.com/questions/4034976/difference-between-read-commited-and-repeatable-read)。

注 4：看起来，repeatable read 和 serialiable 一模一样。实际上确实是，但是二者的实现机制略有区别。详见下面几节。

## 隔离原理
在讲述隔离原理之前，需要先了解什么是一致性读取（consistent read），它是 InnoDB 在 Read committed 和 Repeatable read 隔离级别下处理 `select` 语句的默认模式。

一致性读取的定义来自文档 [15.7.2.3 Consistent Nonlocking Reads](https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html)；隔离原理来自文档 [15.7.2.1 Transaction Isolation Levels](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html)；锁定读取来自文档 [15.7.2.4 Locking Reads](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html)。

### 一致性读取
一致性读取（consistent read）全称一致性非锁定读取（Consistent Nonlocking Reads）。它的意思是 InnoDB 使用多版本控制（multi-versioning）机制向一次查询提供某个时间点的数据库快照（snapshot）。该查询可以看到在那个时间点之前就已经提交的事务所做的改变，**无法看到之后或者未提交的事务所做的改变**（注意此机制防止了脏读现象，因为“无法看到未提交事务所做的改变”）。有一个例外是，在相同事务中，查询可以看见早先语句所做的改变。这种例外可能导致以下异常：如果更新了表中的某些行，SELECT 会看到更新行的最新版本，但也可能会看到它们的旧版本。

**如果事务的隔离级别是 Repeatable read**，那么相同事务内所有的一致性读取都将从快照中读取，该快照在该事务第一次读取时建立。通过提交当前事务并在提交后发出新查询，以此获取更新的快照。**保证了事务内读取的数据是一致的**。

```sql
begin;
select ...  -- 建立快照
.....  -- 执行的一系列操作都基于以上快照，即使此时其它事务修改了数据，当前事务也看不见。
commit;
select ... -- 提交后，这条语句获取新快照。
```

这被称为**多版本并发控制**（multi-versioned concurrency control, MVCC）。

如果你希望在事务期间获得新的快照，要么改用 Read committed 隔离级别，要么使用读锁（read lock），即 `SELECT * FROM t FOR SHARE`。

**如果事务的隔离级别是 Read committed**，事务中的每个一致读取都会设置并读取自己的新快照。

```sql
begin;
select ...  -- 建立快照
select ...  -- 建立快照
commit;
```

**注意一致性读取在访问一些表时不会加任何的锁，因此其它会话可以在一致性读取时同时修改（增删改）这些表**。

### 各个隔离级别的原理

下面介绍各个隔离级别的原理：

**Read uncommitted** 以无锁的方式执行，可能会看到一行的以前版本。

**Read committed**：事务中的每个一致读取都会设置并读取自己的新快照。注意：快照机制保证了不会出现脏读现象，因为该查询“可以看到在当前时间点之前就已经提交的事务所做的改变，无法看到未提交事务所做的改变”，这是其本身的定义，详见上节《一致性读取》。

对于锁定读取（`select` 配合 `for update` 或者 `for share`），`update` 语句和 `delete` 语句这些特殊情况，详见原文档。

**Repeatable read**：相同事务内（一致性读取）读取在第一次读取时构建的快照，详见上文。

对于锁定读取（`select` 配合 `for update` 或者 `for share`），`update` 语句和 `delete` 语句，锁定（locking）取决于语句（statement）是否使用唯一索引（unique index）进行条件查询，或者是否执行一个范围查询。

- 对于使用唯一索引进行条件查询，InnoDB 仅锁住找到的索引记录，而不是锁定间隙，即记录锁（record lock）。
- 对于其它查询条件，InnoDB 锁定扫描到的索引范围，使用间隙锁（gap lock）或者临键锁（next-key lock）阻塞其它会话往该范围内插入数据。*关于间隙锁和临键锁的详细信息，可以往下看，也可以百度。*

**Serializable** 类似于 Repeatable read，但是如果禁用了 `autocommit`，InnoDB 内部将所有普通的 `select` 语句转换为 `select ... for share`，即上共享锁（share lock），亦作读锁，也就是说是只读的；如果启用了 `autocommit`，`select` 就执行自己的事务（不太懂这句话是啥意思，什么叫自己的事务）。

### 什么是锁定读取？
锁定读取（locking reads）就是指 `select ... for share / update`。

假设你查询了数据，然后在相同事务内插入或者更新了相关数据，那么常规的 `select` 无法给予足够的保护。其它事务可以更新或者删除你查询的那一行。InnoDB 支持两种锁定读取类型，提供了额外的安全性。

1. `select ... for share`：为被读取的任意行设置共享锁（shared lock）。其它会话可以读取这些行，但是不能修改（*删改*）它们，直至事务结束。  
> 注意：`select ... for share` 是 `select ... lock in share mode` 的替代品，不过 `lock in share mode` 仍可用于向后兼容。两条语句是等价的。
2. `select ... for update`：对于查到的索引记录（index record**s**），锁定对应的行以及所有相关的索引（index entries）。其它事务被阻止更新这些行，无法执行以下操作：1）`select ... from share`；2）或从某种事务隔离级别中读取数据。*根据以上内容，可以猜测这应该是独占锁（exclusive lock）。*

注意：外部声明（statement）中的“锁定读取”语句无法锁定嵌套子查询中的表中的行。例如，以下声明无法锁定表 t2 中的行（本段的“声明”指完整的 sql 语句）：

```sql
SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2) FOR UPDATE;
```

如果想要锁定表 t2，就在子查询中加入一个锁定读取语句：

```sql
SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2 FOR UPDATE) FOR UPDATE;
```

### 总结

下面是对本节信息以及上节信息的提炼：

- Read uncommitted：不做任何保证。
- Read committed：保证读取到已提交的数据。但是不保证同一事务中读取同一行数据是一致的；可能出现更新丢失。
- Repeatable read：保证同一事务中读取同一行数据是一致的。可能出现更新丢失。
- Serializable：保证当前事务操作的数据范围内，其它事务必须等待。

## InnoDB锁
来自官方文档 [15.7.1 InnoDB Locking](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html)。

### 共享锁和独占锁
InnoDB 实现了标准的行级别锁定，共有两种：

- 共享锁（shared (s) lock），亦称读锁（read lock），允许事务在读取一行时获得一把锁。
- 独占锁（exclusive (x) lock），亦称写锁（write lock），允许事务在更新或删除一行时获得一把锁。

如果事务 T1 在 r 行有一把共享锁，那么请求 r 行的另一个事务 T2 可以按以下方式处理锁：

- 如果 T2 请求共享锁，那么被立即授予。最终，T1 和 T2 都有 r 行的共享锁。（同一个共享锁可以被不同的事务获得）
- 如果 T2 请求独占锁，那么不能被立即授予。（也就是说 r 行只允许 T1 读，不允许 T2 更新或删除）

如果事务 T1 在 r 行有一把独占锁，那么请求 r 行的另一个事务 T2 无法立即获得任意类型的锁。（也就是说 r 行只允许 T1 操作，不允许 T2 读取、更新或删除，即禁止所有操作）

### Intention Locks
前置知识：`LOCK TABLES ... WRITE` 可以为**一张表**加写锁。`LOCK TABLES ... READ`可以为**一张表**加读锁。

意向锁（intention lock）是一种表级锁。

当申请行级锁时，即 `SELECT ... FOR SHARE / UPDATE`，数据库自动为表申请对应的意向锁。

那么意向锁有啥用呢？**主要用于解决表级冲突**。

例如，事务 A 获得了数据表中**某行**的读锁，这意味着对于该行其它事务只能读不能写。现在假设事务 B 想要为该数据**表**加写锁，即 `LOCK TABLES ... WRITE`，这意味事务 B 可以修改**表**中的**任意**数据。由于**表**中已经有一**行**获得了读锁，因此事务 B 必定会失败，否则会冲突。

那么该怎么禁止事务 B 获得写锁呢？有一种比较好想到的方法是，遍历表中的所有数据，并且判断是否冲突。不过这肯定很慢。因此，意向锁诞生了。

在事务 A 获得数据表中**某行**的读锁前，该**表**被数据库自动加上意向读锁。

**表级**的意向读锁和**表级**的写锁是冲突的，所以判断结束。

上述例子参考[知乎文章](https://www.zhihu.com/question/51513268/answer/127777478)。**表级**锁的冲突参考[文档](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html)。

### Record Locks
记录锁（record lock）锁定一条索引记录。例如，`SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE`。这防止事务 inserting / updating / deleting `t.c1 = 10` 的任意一行。

记录锁永远都锁定记录索引，即使一张表内没有定义索引。对于这种例子，InnoDB 创建一个 hidden clustered index 然后用它执行记录锁。详见 [Section 15.6.2.1, “Clustered and Secondary Indexes”](https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html)。

### Gap Locks
间隙锁（gap lock）锁定索引记录之间的间隙，或者是第一个索引记录之前或最后一个索引记录之后的间隙。例如，`SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE`。这防止其它事务插入 `c.t1 = 15` 的数据，无论是否存在这样的数据，因为这个范围的间隙已经被锁定。

间隙可能横跨单个索引值或者多个索引值，甚至可以是空的。

**对于使用唯一索引（unique index）的查询（行唯一），间隙锁是不需要的。例如，对于 `SELECT * FROM child WHERE id = 100;`，该语句只会获得 `id=100` 这行的记录锁（record lock）。**

**如果 `id` *不是索引*或者不是唯一索引，那么语句锁定该索引记录之前的间隙。（据我所知，如果 `id` 不是索引，应该是锁住整张表。）**

**值得注意的是，不同事务的同个间隙可以拥有<font style="color:#ed556a">冲突的锁</font>。**例如，两个事务在同一个间隙上，事务 A 可以拥有共享间隙锁，事务 B 可以拥有独占间隙锁。（*共享锁和独占锁原本是冲突的。*）

……

### Next-Key Locks
临键锁（next-key lock）是一种组合锁，由索引记录的“记录锁”及其之前间隙的“间隙锁”组成。

……

默认情况下，InnoDB 使用 repeatable read 隔离级别。此时，InnoDB 为查询（search）和索引扫描（index scan）使用临键锁，这防止了幻读现象。

以上是临键锁的基本定义。例如现有两个间隙 (5, 10) 和 (10, 15)，查询 10 时，会获得记录锁 10 和 10 之前的间隙，因此获得了 (5, 10] 这个临键锁。

[然而实际上，为了避免发生幻读，需要把所有可能插入 10 这个值的位置都加上锁。](https://www.zhihu.com/question/334081090/answer/1882156445)

所以获得的锁其实是 (5, 15)。

查询 8 时同理，根据定义会获得 (5, 8]。然而实际上会获得 (5, 10) 这个间隙锁。


### Insert Intention Locks
插入意向锁（insert intention lock）是在插入一行之前由 `INSERT` 设置的一种间隙锁类型。该锁标志着插入的意向以以下方式进行：如果多个事务向同一个索引间隙（gap）插入，但在间隙的不同位置，那么它们无需互相等待。

……

### AUTO-INC Locks
自增锁（auto-inc lock）是一种特殊的表级锁，指的是事务向表中插入带有自增的列。在最简单的情况下，如果一个事务正在插入，那么其它所有事务必须等待，以便第一个事务所插入的行接收连续的主键值。

……

### Predicate Locks for Spatial Indexes

## 锁总结
上一节关于锁的定义概括自 mysql 文档。我看得比较混乱，翻译得也很无语，感觉外国人的思维和我不一样。下面先总结再给出一些具体的例子。

### 总结
- 如果使用非索引进行查询，会锁住整张表
- 如果使用索引进行查询，则
	+ 进行等值查询时，如果数据存在，则获得记录锁。
		* 如果使用的非唯一索引，那么就会获得索引之前间隙的间隙锁  
		（进行等值查询时，如果数据横跨两个间隙锁，那么就合并两个间隙锁，得到新的间隙锁）
	+ 进行等值查询时，如果数据不存在，则获得间隙锁。
	+ 进行范围查询时，无论使用什么索引，都会获得临键锁。此时，临键锁是左开右闭的。

### 样例说明

以下是用于测试的员工信息表结构，包含主键 `id` 和 `age`。表中包含数据 (1, 25), (2, 29), (3, 21), (4, 32), (5, 18)。

![测试表结构](img/测试表结构.png)

这样，`age` 索引的潜在临键锁将覆盖如下间隔（interval）：(负无穷, 18], (18, 21], (21, 25], (25, 29], (29, 32], (32, 正无穷]。其中圆括号代表不包括间隔的端点，方括号代表包括间隔的端点，即左开右闭。更具体来说，对于间隔 (18, 21]，(18, 21) 是间隙锁的锁定范围，21 是记录锁的锁定范围。[参考文章](https://tonydong.blog.csdn.net/article/details/103324323#_321)。

<font style="color:#ed556a">此外，在上面的例子中，`age` 是一个**普通索引**。如果 `age` 是唯一索引，那么就会退化为记录锁。如果 `age` 不是索引，则下面的结论不成立，数据库会直接将整张表锁住。</font>

![普通索引age](img/普通索引age.png)

一定要仔细阅读上述针对例子的详细说明，或者在阅读下方的总结时结合上述说明。上述说明非常重要。

### 记录锁
记录锁比较简单，它可以锁住记录，下面提供了两个例子。

注意：`age` 是索引。如果不是索引，`select * from tb_lock where age = 25 for update;` 会锁住整张表。

```sql
begin;
select * from tb_lock where id = 1 for update; # 锁定主键 id = 1 的记录，即记录锁。

update tb_lock set age= 25 where id = 1; # 一直阻塞。
update tb_lock set age= 29 where id = 2; # 执行成功。

begin;
select * from tb_lock where age = 25 for update; # 通过某个索引锁定记录也是可行的。
# 注意：由于 age 不是唯一索引（unique index），因此该语句获得间隙锁。此处只讨论记录锁，不讨论间隙锁。
# 详见间隙锁章节。
```

### 间隙锁
现在假设数据表中还有一条 `id=75` 的数据。如果使用唯一索引查询一条不存在的数据，就会获得间隙锁，而不是记录锁。

```sql
# id=22 这条数据并不存在 
begin;
select * from tb_lock where id = 22 for update # 获得间隙锁 (5, 75)。

update tb_lock set age = 18 where id = 5; # 执行成功。该数据不在间隙锁范围内。
update tb_lock set age = 28 where id = 75; # 执行成功。该数据不在间隙锁范围内。
insert into tb_lock (id, age) values(6, 55); # 一直阻塞。该数据在间隙锁范围内。
insert into tb_lock (id, age) values(74, 55); # 一直阻塞。该数据在间隙锁范围内。
```

-----
当使用非唯一索引时，如果记录不存在也会获得间隙锁。当查询 `age = 27` 时，我们就获得了“间隙锁” (25, 29)。

```sql
begin;
select * from tb_lock where age = 27 for update; # 获得间隙锁 (25, 29)。

insert into tb_lock (age) values(25); # 一直阻塞。
insert into tb_lock (age) values(29); # 执行成功。增。
delete from tb_lock where id = 2; # 执行成功。删。
update tb_lock set age= 29 where id = 2; # 执行成功。改。
```

注意上方的例子，插入 `age = 25` 的语句被阻塞了。这样，看起来临键锁是 [25, 29)，实际上不是的。

现在假设数据表中存在一条 `id=10, age=25` 的数据，`insert into tb_lock (age) values(25);` 被阻塞是因为，mysql 的主键自增策略所生成的 id 一定大于 10。因此待插入数据 `id=?, age=25` 被放在了 `id=10, age=25` 的后面。由于有间隙锁 (25, 29)，因此被阻塞。你可以把数据表想象成一棵 B+ tree。如果索引记录相同，那么 id 较大的结点会被放在 id 较小结点的后面；反之亦反。

执行 `insert into tb_lock (id, age) values(7, 25);`，你会发现执行成功了。这是因为 `id=7, age=25` 被插入到了 `id=10, age=25` 的前面，间隙锁 (25, 29) 没有锁住 `id=10, age=25` 的前面。

**无论用哪个索引操作数据，都是以主键索引为准！**

执行插入 `id = 19, age = 29` 的语句成功了。这符合直觉，因为 `age = 29` 这条数据本身就是开的。现在假设数据表中存在一条 `id=20, age=29` 的数据，执行以下语句，你会发现语句被阻塞了。

```sql
insert into tb_lock (id, age) values(19, 29);
```

原理相同，因为这条数据将被插入到数据 `id=20, age=29` 之前。

-----

当查询 `age = 25` 时，首先获得了 25 这个记录锁。此外，由于 25 横跨了两个间隙锁，即 (21, 25) 和 (25, 29)，因此获得了间隙锁 (21, 29)。

实际上获得的是 25 的记录锁以及之前间隙 (21, 25) 的间隙锁，也就是临键锁 (21, 25]，但是为了避免幻读还要把后面的间隙也锁上。因此是间隙锁 (21, 29)。参考[InnoDB的next-key lock 为什么是左开右闭的？](https://www.zhihu.com/question/334081090/answer/1882156445)。

```sql
begin;
select * from tb_lock where age = 25 for update; # 获得临键锁 (21, 29)

# 其中 id=1 的数据，age=25。显然 25 和 26 都在临键锁 (21, 29) 之间。
insert into tb_lock (age) values(26); # 一直阻塞。
delete from tb_lock where id = 1; # 一直阻塞。
update tb_lock set age= 25 where id = 1; # 一直阻塞。

# 下面测试边界。其中 id=3 的数据，age=29。
insert into tb_lock (age) values(21); # 一直阻塞。注意 id 是自增的。
insert into tb_lock (age) values(29); # 执行成功。注意 id 是自增的。
delete from tb_lock where id = 3; # 执行成功。注意临键锁本来就不包括这条数据。
update tb_lock set age= 21 where id = 3; # 执行成功。注意临键锁本来就不包括这条数据。
delete from tb_lock where id = 2; # 执行成功。注意临键锁本来就不包括这条数据。
update tb_lock set age= 29 where id = 2; # 执行成功。注意临键锁本来就不包括这条数据。

```

### 临键锁
当查询 `age > 21 and age < 31` 时，也就是说是范围查询，而不是等值查询，那么这些记录就横跨三个间隙锁 (21, 25)，(25, 29) 和 (29, 32)。根据经验，推理出获得了临键锁 (21, 32)。

大部分都跟上面的例子一样。有一点不同，我们无法删改 32 这条记录。然而，插入的情况却没有变化，即可以插入到索引记录的后面，但是无法插入到前面。按理说，mysql 并没有获得 32 这个记录锁。

**暂时不清楚是为什么！**可以理解为，在范围查询时，临键锁是左开右闭的，因此临键锁其实是 (21, 32]。

```sql
begin;
select * from tb_lock where age > 21 and age < 31 for update; # 锁定索引记录的间隙

delete from tb_lock where id = 4; # 一直阻塞。
update tb_lock set age= 32 where id = 4; # 一直阻塞。
```

## 自动加锁
[该文档](https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html)详细解释了不同的语句是如何加锁的。

简而言之，在增删改时都会自动上锁，但是锁的类型不同。

## 可重复读隔离级别解决幻读问题？
在 mysql 中，可重复读隔离级别是没有幻读现象的。

首先，在 read committed 和 repeatable read 隔离级别下，如果不加锁，那么 InnoDB 使用的是一致性非锁定读取，简称一致性读取。InnoDB 读取到的是某个时间点的数据库快照，因此也被称为**快照读**。

其次，在 repeatable read 和 serializable 隔离级别下，如果加锁，那么 InnoDB 使用的是**锁定读**（locking read）。具体来说，InnoDB 利用了临键锁。此外，网上也有人将锁定读称为“当前读”。

总而言之，**在快照读时，InnoDB 利用快照防止了幻读现象；在锁定读时，InnoDB 利用临键锁防止了幻读现象。**

## 更新丢失
更新丢失（lost updates）并不是读取现象。

> 在 Read committed 的隔离级别可能发生更新丢失。只要将隔离级别设置成 Repeatable read 就可以防止。值得注意的是，有一个更好的方法也可以防止更新丢失，就是使用乐观锁的方式，即配合 `@Version`。Repeatable read 和 Serializable 可行，但是会有较大的性能影响。[引用](https://stackoverflow.com/questions/49365965/default-transactional-in-spring-and-the-default-lost-update)。  
> 
> *博主注：该描述可能是错的。在 InnoDB 中，即使设置了 Repeatable read，仍旧无法防止更新丢失。因为 InnoDB 实现 repeatable read 并非基于锁，而是快照。最好还是用乐观锁，即加入 version 字段，简单且高效。*


## 死锁
死锁是指两个事务互相等待，一个事物需要使用的资源也是其它事务所需的。

死锁可能由很多原因引起，下面说一个简单的例子。

在查询某些数据时，事务 A 在索引上获得 S 锁，此时事务尚未提交。同时，事务 B 也想要获得这些数据的 S 锁。注意，S 锁并不互斥。

然后事务 A 想要更新之前查出来的数据，为此数据库自动地想要获得 X 锁（在 `UPDATE` 时，数据库会自动加 X 临键锁或者 X 记录锁）。这时，事务 A 被阻塞了。这是因为 S 锁和 X 锁冲突（不同事务之间）。同时事务 B 也想要更新这些数据，数据库也想获得 S 锁。这时，事务 B 也被阻塞了。

最终，在双方都被阻塞的情况下，发生了死锁。

## Spring事务和锁
使用 `@Lock` 注解可以给查询加锁，其中可以指定锁的类型：

1. `READ`：`OPTIMISTIC` 的同义词，对于新应用，倾向于使用后者。
2. `WRITE`：`OPTIMISTIC_FORCE_INCREMENT` 的同义词，对于新应用，倾向于使用后者。
3. `OPTIMISTIC`：乐观锁。不加锁，认为在取数据时其它事务不会修改，但是之后的更新操作时会判断数据是否被其它事务修改。如果有，则返回冲突报错信息。实现原理是，为表新增一个 `version` 字段，每次更新都需要对其 +1。**注意：此类型不会 +1，因为它的语义是认为事务只做读操作。**
4. `OPTIMISTIC_FORCE_INCREMENT`：同上，在更新数据时，`version` +1。
5. `PESSIMISTIC_READ`：共享锁（share lock）。*其它事务可以读当前数据，但不能删改。*
6. `PESSIMISTIC_WRITE`：独占锁（exclusive lock）。*阻塞其它事务对当前数据的一切操作*
7. `PESSIMISTIC_FORCE_INCREMENT`
8. `NONE`：不加锁

## 参考资料
- [通过各种简单案例，让你彻底搞懂 MySQL 中的锁机制与 MVCC](https://tonydong.blog.csdn.net/article/details/103324323#_321)
