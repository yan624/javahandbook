无论在漫威图谱还是航班图谱中，你会发现这些图谱都是在一个给定的模式下构建的，也就是说它在未来很难会扩展。然而小说中的各种关系都是不定的，不同作者可能对关系有不同的定义。因此不可能将关系写死在代码中。本文将关系分为静态关系和动态关系。

静态关系，即系统中定义的关系几乎不会变化，只有在项目进行大版本更新或重构时才可能会有变化，例如航班系统。

动态关系，即系统每隔几个小版本，关系就会变化，甚至系统在运行时，用户就在不停地创建新的关系，例如人物关系图谱。

不幸的是，Spring Data Neo4j (SDN) 并没有为我们提供操作动态关系的功能。我们只能使用拼接查询语句的方式操作关系。幸运的是，SDN 提供了一个 `Neo4jClient`，它帮我们处理了很多繁琐的事，例如事务、结果映射。本文将使用 `Neo4jClient` 完成一个人物关系管理系统。



## 人物结点以及仓库的定义
由于本章不再使用 Spring Data Neo4j (SDN) 维护关系，因此结点实体的定义较为简单。下面给出人物结点以及仓库的定义：

```java
import lombok.Data;
import lombok.ToString;
import org.springframework.data.neo4j.core.schema.GeneratedValue;
import org.springframework.data.neo4j.core.schema.Id;
import org.springframework.data.neo4j.core.schema.Node;

import java.io.Serializable;
import java.util.Set;
import java.util.UUID;

@Data
@ToString
@Node("Portrait")
public class Portrait implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(value = GeneratedValue.UUIDGenerator.class)
    private UUID id;

    private String name;

    private Set<String> aliases;

    private Integer gender;

    private String shortDesc;
}
```

```java
public interface PortraitRepository extends Neo4jRepository<Portrait, UUID> {}
```

## 增删改查人物
SDN 提供了基本的增删改查功能，例如 `save()` / `deleteById()` / `save()` / `findById()`。这些方法在以前已经演示过，下面仅描述调用相应的方法后数据库中发生的变化。具体的代码可以在 github 中找到。

调用 `save()` 方法可以保存一个人物结点。携带以下数据以 post 的方式访问 `/portraits` 即可新增一个人物。

```json
{
    "name": "林雷",
    "aliases": ["林雷·巴鲁克", "林雷·巴鲁克"],
    "gender": 0,
    "shortDesc": "本书主角"
}
```

在 Neo4j Browser 中输入 `MATCH (n:Portrait) RETURN n LIMIT 25`，可以发现已经添加成功。值得注意的是，虽然 neo4j 没有集合这种数据类型，但是可以在 java 中将 `aliases` 定义为集合。接下来再添加几个人物吧，最终如下图所示，数据可以在 github 上获取。

![新增一些结点](img/盘龙图谱_新增一些结点.png ':size=60%')

删除与修改操作类似。删除可以调用 `deleteById()`，修改还是使用 `save()`。

值得注意的是，在更新人物的信息时，如果只携带以下数据：

```json
{
    "id": "931c6c4c-3352-4514-8ba0-3de9b50bf319",
    "gender": 1
}
```

那么该结点的其它属性就会被删除，只保留 `gender`。这是因为在本例中 `save()` 方法统一发出下列语句：

```cypher
MERGE (portrait:`Portrait` {id: $__id__}) SET portrait += $__properties__ RETURN portrait
```

因此想要更新一个结点的正确做法是，先将结点查询出来，然后更新结点实体，最后将实体存入 neo4j。

## 合并

### 合并不重复的独立结点
将 `p1` 收集起来，`all()` 代表参数（即收集的列表）中的内容每个都必须是 `true`。

```cypher
OPTIONAL MATCH (p1:Portrait {novelId: 1})
with collect(p1) as A_p
OPTIONAL MATCH (p2:Portrait {novelId: 2})
where isEmpty(A_p) or (not exists((p2)--()) and all(t in A_p where p2.name <> t.name))
return p2
```

那么怎么将不重复的结点合并如大图谱呢？只需要创建该结点，并且复制属性即可。值得注意的是，需要修改小说id，并且重新生成一个 uuid。

```cypher
OPTIONAL MATCH (p1:Portrait {novelId: 3})
with collect(p1) as A_p
OPTIONAL MATCH (p2:Portrait {novelId: 2})
where isEmpty(A_p) or all(t in A_p where p2.name <> t.name)
// return p2

create (copy:Portrait {is_merged_into: true})
set copy = p2, copy.novelId = 1, copy.id = randomUUID() // uuid可以让后端传入，防止id生成逻辑与查询语句耦合
RETURN copy
```

不过上述有个小 bug，当 `p2` 为 `null` 时，会报异常：Expected NullCheckVariable(1,NodeFromSlot(1,p2)) to be a map, but it was :`NO_VALUE`。怎么在 `p2` 为 `null` 时不执行 `create` 呢？

你可能会想在 `create` 下面加一个 `where` 判断，但实际上不行。这是语法错误。我们可以使用 `foreach` 语句（如果是 `null`，遍历语句就不会执行）：

```cypher
OPTIONAL MATCH (p1:Portrait {novelId: 3})
with collect(p1) as A_p
OPTIONAL MATCH (p2:Portrait {novelId: 3})
where isEmpty(A_p) or all(t in A_p where p2.name <> t.name)
// return p2

with collect(p2) as B_p
FOREACH (n IN B_p | 
create (copy:Portrait {is_merged_into: true})
set copy = n, copy.novelId = 1, copy.id = randomUUID() // uuid 可以让后端传入，防止id生成逻辑与查询语句耦合
)
```

### 合并相同路径但不同关系的路径
可以使用如下语句查询出相同路径但不同关系的路径。

```cypher
OPTIONAL MATCH path1 = (sp1:Portrait {novelId: 1})-[r1]->(ep1:Portrait {novelId: 1})
WITH relationships(path1) AS rels
unwind rels as r // 注释这行以及下一行，下面的 match 就遍历 rels，再做匹配
with collect(r) as rels // 相当于 for _ in rels: optional match
// 在 collect 变量后，即可避免上述情况。可能是因为 collect 返回的不是列表，而是一个迭代函数？
OPTIONAL MATCH path2 = (sp2:Portrait {novelId: 2})-[r2]->(ep2:Portrait {novelId: 2})
// 按照下列匹配逻辑，只要当前结点匹配到列表中的任意一个就算满足条件。
// 但是要正反匹配，因为 a-r->b 和 a<-r-b 是不匹配的，主要是因为用了 startNode 和 endNode 两个函数。
WHERE any(_rel in rels where sp2.name = startNode(_rel).name and ep2.name = endNode(_rel).name and type(r2) <> type(_rel)) or any(_rel in rels where ep2.name = startNode(_rel).name and sp2.name = endNode(_rel).name and type(r2) <> type(_rel))
RETURN path2
```

由于按条件创建一条路径过于复杂，因此可以代码层面处理。在得到上面的路径之后，执行如下创建操作：

```cypher
OPTIONAL MATCH (n1)
WHERE n1.name = "$name1 and n1.novelId = 1
OPTIONAL MATCH (n2)
WHERE n2.name = $name2 and n2.novelId = 1
with collect(n1) + collect(n2) AS res
return size(res) = 2

// 测试
OPTIONAL MATCH (n1)
WHERE n1.name = "林雷" and n1.novelId = 1
OPTIONAL MATCH (n2)
WHERE n2.name = "迪莉娅" and n2.novelId = 1
with collect(n1) + collect(n2) AS res
return size(res) = 2
```

如果起止结点都只有一个，那么就开始合并操作。

```cypher
OPTIONAL MATCH (n1)
WHERE n1.name = $name1 and n1.novelId = 1
OPTIONAL MATCH (n2)
WHERE n2.name = $name2 and n2.novelId = 1
CREATE path = (n1)-[r:拼接字符串成关系标签 $props]->(n2)
RETURN path

// 测试
OPTIONAL MATCH (n1)
WHERE n1.name = "林雷" and n1.novelId = 1
OPTIONAL MATCH (n2)
WHERE n2.name = "迪莉娅" and n2.novelId = 1
CREATE path = (n1)-[r:QINLV]->(n2)
RETURN path
```






