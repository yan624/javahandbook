## 笛卡尔积警告
[Why does neo4j warn: "This query builds a cartesian product between disconnected patterns"?](https://stackoverflow.com/questions/33352673/why-does-neo4j-warn-this-query-builds-a-cartesian-product-between-disconnected?r=SearchResults)

以下语句报出了“If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts...”警告。

```cypher
MATCH (s), (e) 
WHERE id(s) = $startId AND id(e) = $endId 
MERGE (s)-[r:FuQi]->(e) 
SET r = $prop
```

该警告其实是合理的，它担心该查询耗费太多性能。但是问题是我已经指明了结点的 `id`，因此是不可能发生笛卡尔积的。

产生这个警告主要是因为 neo4j 可能不知道 `where` 语句中还指明了 id，所以它会比对每个 s 和 e。这样时间复杂度就是 $O(n^2)$。你可能会觉得当一组 s 和 e 符合匹配要求时，就找到了我们想要的结果。但是 neo4j 并不知道这一点。它以为还会有其它结点也符合这个要求，于是继续比对。直到遍历完 $n^2$ 个组合。因此以上做法非常耗时。

以下做法更高效。

```cypher
MATCH (s)
WITH s // 新版本的 neo4j 可以不加这句，他们做过优化
MATCH (e) 
WHERE id(s) = $startId AND id(e) = $endId 
MERGE (s)-[r:FuQi]->(e) 
SET r = $prop
```

也可以是

```cypher
MATCH (s)
WHERE id(s) = $startId
MATCH (e) 
WHERE id(e) = $endId 
MERGE (s)-[r:FuQi]->(e) 
SET r = $prop
```

## 不要将neo4j的内部id作为实体长期的唯一身份
[Neo4J get node by ID](https://stackoverflow.com/questions/22369520/neo4j-get-node-by-id)

[Get node or relationship by id](https://neo4j.com/docs/cypher-manual/current/clauses/match/#get-node-rel-by-id)

当结点或实体被删除时，Neo4j 会重新使用这些 id。这意味着应用使用、依赖 neo4j 内部 id 是十分脆弱的，可能有风险。建议自己生成 id。















